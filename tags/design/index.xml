<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design on Code with Hugo</title>
    <link>https://codewithhugo.com/tags/design/</link>
    <description>Recent content in Design on Code with Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sun, 22 Apr 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://codewithhugo.com/tags/design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How components won the “framework wars”</title>
      <link>https://codewithhugo.com/how-components-won-the-framework-wars/</link>
      <pubDate>Sun, 22 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://codewithhugo.com/how-components-won-the-framework-wars/</guid>
      <description>

&lt;p&gt;React vs Angular vs Vue: Why it doesn’t matter.&lt;/p&gt;

&lt;h2 id=&#34;2018-marks-the-end-of-javascript-fatigue-and-the-framework-wars&#34;&gt;2018 marks the end of JavaScript fatigue and the “framework wars”&lt;/h2&gt;

&lt;p&gt;A typical frontend/JavaScript developer career usually involves some jQuery and associated plugins before moving on to React, Angular or Vue.&lt;/p&gt;

&lt;p&gt;Having experienced React, Vue and Angular, it seems they solve similar problems in a similar way. Where they differ is the setup experience and best-practices. In more ways than one, the mental model of these frameworks/libraries have converged to the component model.&lt;/p&gt;

&lt;p&gt;This is a win for the developers since the mental model is the same for all the most widespread frameworks. Which means going from one to the other does not pose as big a challenge as it used to.&lt;/p&gt;

&lt;p&gt;If you came here to read a more thorough review and have more background to the Vue, React and Angular ecosystems, I recommend the following from last summer:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/unicorn-supplies/angular-vs-react-vs-vue-a-2017-comparison-c5c52d620176&#34;&gt;&lt;strong&gt;Angular vs. React vs. Vue: A 2017 comparison&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-component-and-composition-model&#34;&gt;The Component and composition model&lt;/h2&gt;

&lt;p&gt;All 3 of the frameworks’ unit of work are the component.
For React you’re extending &lt;code&gt;React.Component&lt;/code&gt;,
in Angular we’re setting up a Module to wrap some component(s) with &lt;code&gt;@NgModule&lt;/code&gt; and &lt;code&gt;@Component&lt;/code&gt; decorators,
in Vue you’re using &lt;code&gt;Vue.component()&lt;/code&gt; to register your components on the Vue instance.&lt;/p&gt;

&lt;p&gt;Everything is based around Components, nesting them within each other, passing data between them and so on.&lt;/p&gt;

&lt;p&gt;As a composition model, components are meant to be self-contained sections or &amp;ldquo;bits&amp;rdquo; of your application that you can
then reuse in more specific contexts.
The great thing they allow is a way to encapsulate logic, providing API guarantees: you pass x, y and z into this component and you will get this foo behaviour out of it, anything the component does internally is its own business.&lt;/p&gt;

&lt;h2 id=&#34;state-and-mutation&#34;&gt;State and mutation&lt;/h2&gt;

&lt;p&gt;The problem that all these frameworks tackle is binding data to the DOM somehow.
This is something that the developer would have to do manually in jQuery for example.&lt;/p&gt;

&lt;p&gt;This means that the most basic application (that uses a framework/library) will hold some sort of state.
The models that Vue, Angular and React themselves (ie. not user-land libraries) expose are actually quite different.&lt;/p&gt;

&lt;p&gt;Angular has the belief that state should be mutable.
It also has affordances for passing services across components and modules usually keeping that service as a
quasi-singleton through dependency injection.
A developer can therefore easily write a data-sharing container that will update the relevant components,
usually through the service returning Observables and components storing subscriptions to them.&lt;/p&gt;

&lt;p&gt;Vue uses a reactivity system to notify the other parts of the application that a change has happened in state.
This gives it a performance edge since using &lt;code&gt;this.property&lt;/code&gt; is actually using a setter under the hood, in that setter,
Vue can send off updates wherever they’re required, and not just send them everywhere.
The preferred mechanism for composing state to render in the template is computed properties.&lt;/p&gt;

&lt;p&gt;React made the notion of immutable state more widespread in the JavaScript ecosystem.
State is not updated by mutating (eg. using &lt;code&gt;state.myProperty&lt;/code&gt;), instead the component’s &lt;code&gt;setState&lt;/code&gt; method
is called with the data to update.&lt;/p&gt;

&lt;p&gt;The encapsulation that components provide however, means that the difference between the specifics of state management is not so obvious when using all these frameworks.&lt;/p&gt;

&lt;p&gt;The preferred pattern in all 3 frameworks is to avoid directly mutating data passed from a parent in favour of informing said parent
that a state change should happen.&lt;/p&gt;

&lt;h2 id=&#34;data-passing&#34;&gt;Data passing&lt;/h2&gt;

&lt;p&gt;Data passing patterns are simplified with a component-based application: the communication is only done from the parent to the child and vice-versa.&lt;/p&gt;

&lt;p&gt;In React, props are passed to pass data but also functions that allow you to update the parent state from the child.&lt;/p&gt;

&lt;p&gt;In Angular, &lt;code&gt;Input&lt;/code&gt; and &lt;code&gt;Output&lt;/code&gt; bindings are defined in the component and bound in the template.
&lt;code&gt;Output&lt;/code&gt;s behave much like events in that they are emitted by the child and listened to by the parent.&lt;/p&gt;

&lt;p&gt;In Vue, props are passed from parent to child and the child can emit events back to the parent.&lt;/p&gt;

&lt;p&gt;The way to pass data between “sibling” components is solved in the same way in all these frameworks by finding the nearest common
parent in the tree and encapsulating state and state updates there.&lt;/p&gt;

&lt;h2 id=&#34;lifecycles-updates-and-re-render&#34;&gt;Lifecycles, updates and re-render&lt;/h2&gt;

&lt;p&gt;Components in React, Vue and Angular update if local state &lt;em&gt;or&lt;/em&gt; props (inputs) change.
If you don’t store any state locally, you could force components to only change when their props change.&lt;/p&gt;

&lt;p&gt;Functional components do that for React and Vue, and &lt;code&gt;ChangeDetection.OnPush&lt;/code&gt; change detection strategy can be used in Angular.&lt;/p&gt;

&lt;p&gt;The component lifecycles are provided under different method names in each framework.&lt;/p&gt;

&lt;p&gt;All three provide a mounted/dismount which refers to the component being initialised in the DOM and it not being needed any more.
It&amp;rsquo;s also possible to listen to updates to data and props which usually trigger a re-render of the template.&lt;/p&gt;

&lt;h2 id=&#34;global-stores&#34;&gt;Global Stores&lt;/h2&gt;

&lt;p&gt;When an application needs shared data in components that are quite far apart in the component tree, it&amp;rsquo;s time to use a store.&lt;/p&gt;

&lt;p&gt;This was initially popularised by the React ecosystem with Facebook’s flux architecture.
Flux consists in passing &lt;code&gt;actions&lt;/code&gt; to the store which knows how to update the store&amp;rsquo;s state depending on the action type.&lt;/p&gt;

&lt;p&gt;In React the options are redux or MobX, Vue has the officially supported Vuex and Angular has ngrx/store.&lt;/p&gt;

&lt;p&gt;This single global store pattern is therefore supported by all these frameworks.
The difference is that the libraries are from the ecosystem for Angular and React whereas Vue&amp;rsquo;s store is supported
by the core team.&lt;/p&gt;

&lt;p&gt;The design of these &amp;ldquo;goto&amp;rdquo; store solutions reflect some of the idiomatic ways to write code with these frameworks:
in Vue it’s object and getter/setter based, in Angular it’s Observables, well-organised effects and so on.
React has the most choice, “just JavaScript” + pure functions (redux), reactive state watchers (MobX) or even plain
JavaScript objects (unstated).&lt;/p&gt;

&lt;h2 id=&#34;types-and-data-validation&#34;&gt;Types and data validation&lt;/h2&gt;

&lt;p&gt;Validating the type of data within an application is helpful for development and debugging.&lt;/p&gt;

&lt;p&gt;JavaScript isn’t statically typed so keeping track of types while passing data through multiple components
and functions can become difficult.&lt;/p&gt;

&lt;p&gt;Vue and React solve this with prop type validation.
A component and its props is defined with typed props, in development mode,
the library will check that passed props match the set prop types.
These annotations and checks get stripped in production builds of the app/library.
The overhead of the checks therefore disappears where performance is most crucial.&lt;/p&gt;

&lt;p&gt;Angular doesn’t have such a prop validation mechanism but has the advantage of generally being written in TypeScript.
The development experience of having statically typed inputs and outputs is great.
These types however get stripped at build time.
Detecting type mismatches at runtime is not possible.
The majority of these type mismatches end up happening in the IDE or compiler.&lt;/p&gt;

&lt;p&gt;React and Vue can also be tooled to leverage type systems such as TypeScript and Flow, which gives them
similar guarantees as developing in Angular and TypeScript.&lt;/p&gt;

&lt;h2 id=&#34;templates-styles-and-tooling&#34;&gt;Templates, styles and tooling&lt;/h2&gt;

&lt;p&gt;Best practices around file structure of an application differ between Angular, Vue and React.&lt;/p&gt;

&lt;p&gt;Angular leans towards one folder per Module/Component where your TypeScript, template and style files live.
Templates and styles can be written inline in the Angular component inline but the best practice is to have separate files.
This is a good idea for large single page applications.&lt;/p&gt;

&lt;p&gt;Vue is called “the progressive framework” because it offers different features depending on the size of the
application being developed.
In the simplest case (Vue globally included using a CDN and script tag), writing templates inline is encouraged.
Vue also offers a CLI and packages that integrate with build tools like webpack.
The preferred way to write components in this environment is the single-file component a file with a template, a
script and a style tag.
Vue-loader compiles the template into JavaScript along with the script section and extracts the contents of the style
tag into a stylesheet at build time.&lt;/p&gt;

&lt;p&gt;In React, since logic and JSX templates cannot be separated, there is just the question of styles.
There are multiple answers: handle styles separately, use webpack to extract your &lt;code&gt;import ‘my.css&#39;&lt;/code&gt;
statements into a stylesheet or use CSS-in-JS libraries.&lt;/p&gt;

&lt;p&gt;For small projects Vue has the nicer ergonomics, for the largest enterprise use-case, Angular has the most structure,
React sits somewhere in between, where the component structure is left as an exercise to the developer but a
build tool is recommended (at least to compile JSX).&lt;/p&gt;

&lt;h2 id=&#34;testing-and-server-side-rendering&#34;&gt;Testing and server side rendering&lt;/h2&gt;

&lt;p&gt;Unit testing in Angular is mainly done on the TypeScript components classes.
To be able to test the template logic would require a full DOM environment (eg. a headless browser).&lt;/p&gt;

&lt;p&gt;In React and Vue, thanks to their use of a Virtual DOM and render functions, testing the template logic is possible using &lt;a href=&#34;https://github.com/airbnb/enzyme&#34;&gt;enzyme&lt;/a&gt;
and &lt;a href=&#34;https://github.com/vuejs/vue-test-utils&#34;&gt;vue-test-utils&lt;/a&gt; respectively.&lt;/p&gt;

&lt;p&gt;Shallow rendering of components means that only the first &amp;ldquo;layer&amp;rdquo; of the component&amp;rsquo;s children is rendered,
ie. all components that are in the children are not fully evaluated (rendered to HTML), instead they are left as &lt;code&gt;ComponentName&lt;/code&gt; in
the component tree.&lt;/p&gt;

&lt;p&gt;This ability to render without a full DOM environment is also useful for server-side rendering of the JavaScript application.
Vue has the &lt;a href=&#34;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&#34;&gt;vue-server-renderer&lt;/a&gt; package and React the &lt;a href=&#34;https://reactjs.org/docs/react-dom-server.html&#34;&gt;ReactDOMServer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;These allow a Node application to convert a hydrated Vue or React app to markup (HTML) usually to be sent back as a HTML response for
the first page load.&lt;/p&gt;

&lt;p&gt;Angular has similar compilation and rendering ability although these features are less &amp;ldquo;drop-in to an existing app&amp;rdquo; and more &amp;ldquo;build with these tools in mind&amp;rdquo;
since some of the framework&amp;rsquo;s features have to be used with caution when using
&lt;a href=&#34;https://angular.io/guide/universal&#34;&gt;Angular Universal&lt;/a&gt; which allows for server-side rendering or
Angular&amp;rsquo;s &lt;a href=&#34;https://angular.io/guide/aot-compiler&#34;&gt;AoT compiler&lt;/a&gt; which
compiles templates to JavaScript and render functions.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s very possible today to double down on component-based frameworks and to move seamlessly between them.&lt;/p&gt;

&lt;p&gt;The concepts around components and how to build an app with them are the same, with framework-specific names
which have a clear mapping across frameworks.&lt;/p&gt;

&lt;p&gt;The only thing still separating React, Vue and Angular is the underlying philosophies and primitives on which they are built.
React leans heavily on developers to pick and choose their preferred tools from the ecosystem (or build them if necessary).
Vue is happy to start off as a simple &lt;code&gt;script&lt;/code&gt; tag include but also provides a coherent toolset to build larger applications
(single file components, Vuex, vue-router, documentation and even a &lt;a href=&#34;https://vuejs.org/v2/style-guide/&#34;&gt;style guide&lt;/a&gt;).
Angular is aimed at large applications and immediately comes with copious amounts of structure and verbosity (using TypeScript)
as well as deeply embracing RxJS and Observables.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>